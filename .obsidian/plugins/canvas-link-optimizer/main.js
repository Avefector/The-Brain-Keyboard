/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvasLinkOptimizerPlugin
});
module.exports = __toCommonJS(main_exports);

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/main.ts
var import_obsidian = require("obsidian");
var CanvasLinkOptimizerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.name = "Canvas Link Optimizer";
    this.cacheDir = `${this.manifest.dir}/data/linkCache`;
  }
  async onload() {
    this.addCommand({
      id: "cleanup-unused-thumbnails",
      name: "Cleanup unused thumbnails",
      callback: () => this.cleanupThumbnails()
    });
    this.registerEvent(
      this.app.workspace.on(`${this.manifest.id}:patched-canvas`, () => {
        this.reloadActiveCanvasViews();
      })
    );
    this.app.vault.adapter.mkdir(this.cacheDir);
    this.app.workspace.onLayoutReady(() => {
      if (!this.tryPatchLinkNode()) {
        const evt = this.app.workspace.on("layout-change", () => {
          this.tryPatchLinkNode() && this.app.workspace.offref(evt);
        });
        this.registerEvent(evt);
      }
    });
    this.log("Plugin loaded");
  }
  onunload() {
    this.log("Unloading plugin");
    this.reloadActiveCanvasViews();
  }
  reloadActiveCanvasViews() {
    this.app.workspace.getLeavesOfType("canvas").map((leaf) => leaf.rebuildView());
  }
  log(msg, debug = false) {
    debug ? console.debug(`[${this.name}]`, msg) : console.log(`[${this.name}]`, msg);
  }
  tryPatchLinkNode() {
    var _a;
    const canvasView = (_a = this.app.workspace.getLeavesOfType("canvas").first()) == null ? void 0 : _a.view;
    if (!canvasView)
      return false;
    const canvas = canvasView == null ? void 0 : canvasView.canvas;
    if (!canvas)
      return false;
    const linkNodeConstructor = this.retrieveLinkNodeConstructor(canvas);
    this.patchLinkNode(linkNodeConstructor);
    return true;
  }
  patchLinkNode(constructor) {
    const thisPlugin = this;
    const uninstaller = around(constructor.prototype, {
      _saveThumbnail: () => async function() {
        if (!this.frameEl)
          return;
        thisPlugin.log(`Saving thumbnail for ${this.url}`);
        const img = await this.frameEl.capturePage();
        this.app.vault.adapter.writeBinary(
          this._getThumbnailPath(),
          img.toJPEG(100)
        );
      },
      _getThumbnailPath: () => function() {
        return `${thisPlugin.cacheDir}/${this.id}.thumbnail.jpg`;
      },
      _getMetadataPath: () => function() {
        return `${thisPlugin.cacheDir}/${this.id}.metadata.json`;
      },
      initialize: (next) => function(...args) {
        this._initializing = true;
        const result = next.call(this, ...args);
        this._initializing = false;
        const saveThumbnail = (0, import_obsidian.debounce)(
          () => this._saveThumbnail(),
          500
        );
        const resizeObserver = new MutationObserver(
          async (mutationList) => {
            for (const mutation of mutationList) {
              if (mutation.type !== "attributes" || mutation.attributeName !== "style")
                continue;
              const target = mutation.target;
              const newWidth = target.style.width;
              const newHeight = target.style.height;
              const oldValue = mutation.oldValue || "";
              const oldWidthMatch = oldValue.match(
                /width:\s*([^;]+)(;|$)/
              );
              const oldHeightMatch = oldValue.match(
                /height:\s*([^;]+)(;|$)/
              );
              const oldWidth = oldWidthMatch ? oldWidthMatch[1].trim() : "";
              const oldHeight = oldHeightMatch ? oldHeightMatch[1].trim() : "";
              if (!oldWidth || !oldHeight || !newWidth || !newHeight)
                return;
              if (newWidth === oldWidth && newHeight === oldHeight)
                return;
              saveThumbnail();
            }
          }
        );
        const config = {
          attributes: true,
          attributeOldValue: true,
          attributeFilter: ["style"]
        };
        resizeObserver.observe(this.nodeEl, config);
        (async () => {
          const revealWebview = () => {
            var _a, _b;
            this.alwaysKeepLoaded = true;
            (_b = (_a = this._perviewImageEl) == null ? void 0 : _a.remove) == null ? void 0 : _b.call(_a);
            this.recreateFrame();
          };
          const [thumbnailExists, metadataExists] = await Promise.all([
            thisPlugin.app.vault.exists(
              this._getThumbnailPath()
            ),
            thisPlugin.app.vault.exists(
              this._getMetadataPath()
            )
          ]);
          if (!thumbnailExists || !metadataExists) {
            this.recreateFrame();
            return;
          }
          this.alwaysKeepLoaded = false;
          const metadataRaw = await thisPlugin.app.vault.adapter.read(
            this._getMetadataPath()
          );
          const metadata = JSON.parse(metadataRaw);
          this.updateNodeLabel(metadata.title);
          this._perviewImageEl = this.contentEl.doc.createElement("img");
          this.contentEl.append(this._perviewImageEl);
          this._perviewImageEl.classList.add("link-thumbnail");
          this._perviewImageEl.alt = "Webpage thumbnail";
          this._perviewImageEl.src = thisPlugin.app.vault.adapter.getResourcePath(
            this._getThumbnailPath()
          );
          this._perviewImageEl.addEventListener(
            "click",
            revealWebview
          );
          this._perviewImageEl.addEventListener(
            "error",
            revealWebview
          );
        })();
        return result;
      },
      recreateFrame: (next) => function(...args) {
        var _a;
        if (this._initializing)
          return null;
        const result = next.call(this, ...args);
        if (((_a = this.frameEl) == null ? void 0 : _a.tagName) === "WEBVIEW") {
          const onFrameLoaded = async () => {
            this.frameEl.removeEventListener(
              "did-frame-finish-load",
              onFrameLoaded
            );
            await sleep(1e3);
            const metadataPath = this._getMetadataPath();
            this.app.vault.adapter.write(
              metadataPath,
              JSON.stringify({
                title: this.frameEl.getTitle()
              })
            );
            await this._saveThumbnail();
            thisPlugin.log(`Cached link ${this.url}`);
          };
          this.frameEl.addEventListener(
            "did-frame-finish-load",
            onFrameLoaded
          );
        }
        return result;
      }
    });
    this.register(uninstaller);
    thisPlugin.log("Canvas patched successfully");
    thisPlugin.app.workspace.trigger(
      `${thisPlugin.manifest.id}:patched-canvas`
    );
    return true;
  }
  retrieveLinkNodeConstructor(canvasInstance) {
    const dummyCanvasInstance = new Proxy({}, { get: () => () => {
    } });
    const dummyNodeParams = {
      pos: { x: 0, y: 0 },
      size: { width: 0, height: 0 },
      position: "center",
      url: "",
      save: false,
      focus: false
    };
    const dummyLinkNode = canvasInstance.createLinkNode.call(
      dummyCanvasInstance,
      dummyNodeParams
    );
    return dummyLinkNode.constructor;
  }
  async cleanupThumbnails() {
    const thumbnails = await this.app.vault.adapter.list(this.cacheDir);
    const thumbnailFiles = thumbnails.files.filter(
      (file) => file.endsWith(".thumbnail.jpg")
    );
    const nodeIds = thumbnailFiles.map((file) => {
      const match = file.match(/([^/]+)\.thumbnail\.jpg$/);
      return match ? match[1] : void 0;
    }).filter((nodeId) => nodeId !== void 0);
    const allFiles = this.app.vault.getFiles();
    const canvasFiles = allFiles.filter(
      (file) => file.path.endsWith(".canvas")
    );
    const usedNodeIds = /* @__PURE__ */ new Set();
    for (const canvasFile of canvasFiles) {
      const content = await this.app.vault.read(canvasFile);
      const nodes = this.extractNodeIdsFromCanvas(content);
      nodes.forEach((nodeId) => usedNodeIds.add(nodeId));
    }
    const unusedNodeIds = nodeIds.filter(
      (nodeId) => !usedNodeIds.has(nodeId)
    );
    for (const nodeId of unusedNodeIds) {
      this.log("Removing cache for missing node " + nodeId);
      const thumbnailFile = `${this.cacheDir}/${nodeId}.thumbnail.jpg`;
      const metadataFile = `${this.cacheDir}/${nodeId}.metadata.json`;
      const removeFile = async (path) => {
        if (await this.app.vault.adapter.exists(path)) {
          await this.app.vault.adapter.remove(path);
        }
      };
      await removeFile(thumbnailFile);
      await removeFile(metadataFile);
    }
    new import_obsidian.Notice(`${unusedNodeIds.length} Unused thumbnails cleaned up!`);
  }
  extractNodeIdsFromCanvas(content) {
    const canvas = JSON.parse(content);
    return (canvas.nodes || []).map((node) => node.id);
  }
};
