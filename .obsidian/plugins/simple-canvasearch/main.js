/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvaSearch
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  searchText: false
};
var current_index;
function focusOnNode(canvas, node) {
  canvas.zoomToBbox({
    minX: node.x - node.width * 1,
    minY: node.y - node.height * 1,
    maxX: node.x + node.width * 1,
    maxY: node.y + node.height * 1
  });
  let node_full = canvas.nodes.get(node.id);
  canvas.deselectAll();
  canvas.select(node_full);
}
var CanvaSearch = class extends import_obsidian.Plugin {
  async index_canvas_notes(searchText) {
    const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    const vault = this.app.vault;
    if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
      const canvas = canvasView.canvas;
      let return_array;
      if (searchText) {
        return_array = canvas.data.nodes.map(async function(a) {
          if (a.type == "file") {
            let content = await vault.cachedRead(
              vault.getAbstractFileByPath(a.file)
            );
            return [a, content];
          }
          if (a.type == "text") {
            let content = a.text;
            return [a, content];
          }
          if (a.type == "link") {
            let content = a.url;
            return [a, content];
          }
          if (a.type == "group") {
            let content = a.label;
            return [a, content];
          }
        });
      } else {
        return_array = canvas.data.nodes.map(async function(a) {
          return [a, ""];
        });
      }
      return await Promise.all(return_array);
    } else
      return [];
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "open-canvasearch-modal",
      name: "Open CanvaSearch modal",
      callback: async () => {
        const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
        if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
          current_index = await this.index_canvas_notes(this.settings.searchText);
          new CanvaSearchModal(this.app).open();
        } else {
          this.openSearchBar();
        }
      }
    });
    this.addSettingTab(new CanvaSearchSettingTab(this.app, this));
  }
  openSearchBar() {
    this.app.commands.executeCommandById("editor:open-search");
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CanvaSearchModal = class extends import_obsidian.FuzzySuggestModal {
  getActiveCanvas() {
    var _a;
    const maybeCanvasView = (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.view;
    return maybeCanvasView ? maybeCanvasView["canvas"] : null;
  }
  constructor(app) {
    super(app);
  }
  getItems() {
    return current_index;
  }
  getItemText(data) {
    let node_data = data[0];
    let node_content = data[1];
    switch (node_data.type) {
      case "file":
        return node_data.file + "\n" + node_content;
      case "group":
        return node_data.label;
      case "text":
        return node_data.text;
      case "link":
        return node_data.url;
      default:
        return "";
    }
  }
  onChooseItem(data, evt) {
    const canvasView = this.app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    const canvas = "";
    if ((canvasView == null ? void 0 : canvasView.getViewType()) === "canvas") {
      const canvas2 = canvasView.canvas;
    }
    let node_data = data[0];
    switch (node_data.type) {
      case "file":
        new import_obsidian.Notice(`Selected ${node_data.file}`);
        focusOnNode(this.getActiveCanvas(), node_data);
        break;
      case "group":
        new import_obsidian.Notice(`Selected ${node_data.file}`);
        focusOnNode(this.getActiveCanvas(), node_data);
        break;
      case "text":
        new import_obsidian.Notice(`Selected ${node_data.text}`);
        focusOnNode(this.getActiveCanvas(), node_data);
        break;
      case "link":
        new import_obsidian.Notice(`Selected ${node_data.url}`);
        break;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText("Woah!");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CanvaSearchSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Include note contents in search").setDesc(
      "Will search inside the notes in your canvas, there is no indexing done so it can be very slow if your canvas is very large."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.searchText);
      toggle.onChange(async (value) => {
        this.plugin.settings.searchText = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
