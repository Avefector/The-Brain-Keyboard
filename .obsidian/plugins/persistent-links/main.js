/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/typed-assert/build/index.js
var require_build = __commonJS({
  "node_modules/typed-assert/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.check = exports.isPromise = exports.isInstanceOf = exports.isOneOfType = exports.isOneOf = exports.isOptionOfType = exports.isArrayOfType = exports.isRecordOfType = exports.isArray = exports.isRecordWithKeys = exports.isRecord = exports.isDate = exports.isString = exports.isNumber = exports.isBoolean = exports.isExactly = exports.isNotVoid = exports.isNotUndefined = exports.isNotNull = exports.isNever = exports.isUnknown = exports.safeJsonParse = exports.setBaseAssert = exports.assert = exports.defaultAssert = void 0;
    var expectedToBe = (type) => `expected to be ${type}`;
    var defaultAssert = (condition, message) => {
      if (!condition) {
        throw new TypeError(message);
      }
    };
    exports.defaultAssert = defaultAssert;
    var baseAssert = exports.defaultAssert;
    var assert = (condition, message) => baseAssert(condition, message);
    exports.assert = assert;
    function setBaseAssert(assert2) {
      if (assert2) {
        baseAssert = assert2;
      }
    }
    exports.setBaseAssert = setBaseAssert;
    var safeJsonParse = (json) => JSON.parse(json);
    exports.safeJsonParse = safeJsonParse;
    function isUnknown(_input) {
      return true;
    }
    exports.isUnknown = isUnknown;
    function isNever(_input, message = expectedToBe("unreachable")) {
      throw new TypeError(message);
    }
    exports.isNever = isNever;
    function isNotNull2(input, message = expectedToBe("not null")) {
      (0, exports.assert)(input !== null, message);
    }
    exports.isNotNull = isNotNull2;
    function isNotUndefined(input, message = expectedToBe("not undefined")) {
      (0, exports.assert)(input !== void 0, message);
    }
    exports.isNotUndefined = isNotUndefined;
    function isNotVoid2(input, message = expectedToBe("neither null nor undefined")) {
      (0, exports.assert)(input !== null && input !== void 0, message);
    }
    exports.isNotVoid = isNotVoid2;
    function isExactly(input, value, message = expectedToBe(`exactly ${value}`)) {
      (0, exports.assert)(input === value, message);
    }
    exports.isExactly = isExactly;
    function isBoolean(input, message = expectedToBe("a boolean")) {
      (0, exports.assert)(typeof input === "boolean", message);
    }
    exports.isBoolean = isBoolean;
    function isNumber(input, message = expectedToBe("a number")) {
      (0, exports.assert)(typeof input === "number", message);
    }
    exports.isNumber = isNumber;
    function isString(input, message = expectedToBe("a string")) {
      (0, exports.assert)(typeof input === "string", message);
    }
    exports.isString = isString;
    function isDate(input, message = expectedToBe("a Date")) {
      (0, exports.assert)(input instanceof Date, message);
    }
    exports.isDate = isDate;
    function isRecord(input, message = expectedToBe("a record")) {
      (0, exports.assert)(typeof input === "object", message);
      isNotNull2(input, message);
      for (const key of Object.keys(input)) {
        isString(key, message);
      }
    }
    exports.isRecord = isRecord;
    function isRecordWithKeys(input, keys, message = expectedToBe(`a record with keys ${keys.join(", ")}`)) {
      isRecord(input, message);
      for (const key of keys) {
        isNotUndefined(input[key]);
      }
    }
    exports.isRecordWithKeys = isRecordWithKeys;
    function isArray(input, message = expectedToBe("an array")) {
      (0, exports.assert)(Array.isArray(input), message);
    }
    exports.isArray = isArray;
    function isRecordOfType(input, assertT, message = expectedToBe("a record of given type"), itemMessage = expectedToBe("of given type")) {
      isRecord(input, message);
      for (const item of Object.values(input)) {
        assertT(item, itemMessage);
      }
    }
    exports.isRecordOfType = isRecordOfType;
    function isArrayOfType(input, assertT, message = expectedToBe("an array of given type"), itemMessage = expectedToBe("of given type")) {
      isArray(input, message);
      for (const item of input) {
        assertT(item, itemMessage);
      }
    }
    exports.isArrayOfType = isArrayOfType;
    function isOptionOfType(input, assertT, message = expectedToBe("option of given type")) {
      if (input === void 0) {
        return;
      }
      assertT(input, message);
    }
    exports.isOptionOfType = isOptionOfType;
    function isOneOf(input, values, message = expectedToBe(`one of ${values.join(", ")}`)) {
      (0, exports.assert)(values.includes(input), message);
    }
    exports.isOneOf = isOneOf;
    function isOneOfType(input, assertT, message = expectedToBe(`one of type`), itemMessage) {
      for (const assert2 of assertT) {
        try {
          assert2(input, itemMessage);
          return;
        } catch (_) {
        }
      }
      throw new TypeError(message);
    }
    exports.isOneOfType = isOneOfType;
    function isInstanceOf2(input, constructor, message = expectedToBe("an instance of given constructor")) {
      (0, exports.assert)(input instanceof constructor, message);
    }
    exports.isInstanceOf = isInstanceOf2;
    function isPromise(input, message = expectedToBe("a promise")) {
      isInstanceOf2(input, Promise, message);
    }
    exports.isPromise = isPromise;
    function check(assertT) {
      return (input) => {
        try {
          assertT(input);
          return true;
        } catch (_) {
          return false;
        }
      };
    }
    exports.check = check;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PersistentLinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_typed_assert = __toESM(require_build());

// src/patterns.ts
var HEADING = /^#+\s.+$/gm;
var BLOCK_ID = /\s+(\^[a-zA-Z0-9-]+)$/gm;
var NOT_LETTER_OR_NUMBER = /[^\p{Letter}\p{Number}]/gu;
var FILE_PATH_IN_LINK = /(\[\[).*(#)/;

// src/utils.ts
var obsidian = __toESM(require("obsidian"));
function getBlockIds(text) {
  return [...text.matchAll(BLOCK_ID)].map((match) => match[1]);
}
function getHeadings(text) {
  return [...text.matchAll(HEADING)].map((match) => match[0]);
}
function normalizeHeading(text) {
  return text.replaceAll(NOT_LETTER_OR_NUMBER, "");
}
function getNormalizedHeadingInLink(link) {
  const headingPart = link.split("#")[1];
  if (headingPart) {
    return normalizeHeading(headingPart);
  }
  return null;
}
function parseLinkText(linkText) {
  const { path, subpath } = obsidian.parseLinktext(linkText);
  return {
    path,
    subpath: stripSubpathToken(subpath)
  };
}
function stripSubpathToken(subpath) {
  return subpath.replace(/#\^?/, "");
}
function replaceFilePathInLink(link, newPath) {
  return link.replace(FILE_PATH_IN_LINK, `$1${newPath}$2`);
}
function filterLinksToItemsPresentInText(links, text) {
  const blockIdsInText = getBlockIds(text);
  const headingsInText = getHeadings(text);
  return Object.entries(links).map(([filePath, links2]) => ({
    filePath,
    links: links2.filter(
      ({ link: linkText }) => blockIdsInText.some((id) => linkText.includes(id)) || headingsInText.some(
        (heading) => getNormalizedHeadingInLink(linkText) === normalizeHeading(heading)
      )
    )
  })).filter(({ links: links2 }) => links2.length > 0);
}
function redirectLinksInTextToNewPaths(linksWithPaths, text) {
  return linksWithPaths.slice().sort((a, b) => compareLinkOffsets(a.link, b.link)).reverse().reduce(
    (updatedText, { newPath, link: { position, original } }) => {
      const start = position.start.offset;
      const end = position.end.offset;
      const updatedLink = replaceFilePathInLink(original, newPath);
      return updatedText.substring(0, start) + updatedLink + updatedText.substring(end);
    },
    text
  );
}
function createUpdateNotice(results) {
  const fileCount = results.length;
  const linkCount = results.flatMap((f) => f.links).length;
  return `Updated ${linkCount} links in ${fileCount} files`;
}
function createRepairNotice(fixed, broken) {
  let result = "";
  if (fixed > 0) {
    result += `Fixed ${fixed} links`;
  }
  if (broken > 0) {
    result += `
Could not fix ${broken} links`;
  }
  return result;
}
function compareLinkOffsets(left, right) {
  return left.position.start.offset - right.position.start.offset;
}
function isSubpathInMetadata(subpath, metadata) {
  if (!metadata) {
    return false;
  }
  const { blocks, headings } = metadata;
  return blocks && subpath in blocks || headings && isSubpathInHeadingCache(subpath, headings);
}
function isSubpathInHeadingCache(subpath, headingCache) {
  return headingCache.some(
    ({ heading }) => normalizeHeading(heading) === normalizeHeading(subpath)
  );
}

// src/main.ts
var PersistentLinksPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.isLinkPathBroken = ({
      path,
      subpath
    }) => {
      const toFile = this.getFileFromPathRelativeToActiveFile(path);
      if (toFile === null) {
        return true;
      }
      return !isSubpathInMetadata(
        subpath,
        this.app.metadataCache.getFileCache(toFile)
      );
    };
    this.handleEditorPaste = async (event) => {
      var _a;
      if (!this.sourceFile) {
        return;
      }
      const clipboardContents = (_a = event == null ? void 0 : event.clipboardData) == null ? void 0 : _a.getData("text");
      if (!clipboardContents) {
        return;
      }
      const backlinksToUpdate = filterLinksToItemsPresentInText(
        this.getBacklinksForSourceFile(),
        clipboardContents
      );
      if (backlinksToUpdate.length === 0) {
        return;
      }
      this.runAfterMetadataUpdateIn(this.getActiveFile(), async () => {
        await this.redirectLinksToActiveFile(backlinksToUpdate);
        new import_obsidian.Notice(createUpdateNotice(backlinksToUpdate));
      });
    };
  }
  async onload() {
    this.addCommand({
      id: "persistent-links:repair-links-in-file",
      name: "Repair links in file",
      editorCallback: (editor) => {
        this.repairLinksInFile(editor);
      }
    });
    const body = document.querySelector("body");
    (0, import_typed_assert.isNotNull)(body);
    this.registerDomEvent(body, "cut", () => {
      this.sourceFile = this.app.workspace.getActiveFile();
    });
    this.app.workspace.on("editor-paste", this.handleEditorPaste);
  }
  onunload() {
    this.app.workspace.off("editor-paste", this.handleEditorPaste);
  }
  repairLinksInFile(editor) {
    const activeFileCache = this.app.metadataCache.getFileCache(
      this.getActiveFile()
    );
    if (!activeFileCache) {
      new import_obsidian.Notice("Nothing to fix");
      return;
    }
    const { links = [], embeds = [] } = activeFileCache;
    const { fixable, broken } = this.findNewPathsForBrokenLinks([
      ...links,
      ...embeds
    ]);
    if (fixable.length > 0) {
      editor.setValue(
        redirectLinksInTextToNewPaths(fixable, editor.getValue())
      );
    }
    new import_obsidian.Notice(createRepairNotice(fixable.length, broken.length));
  }
  findNewPathsForBrokenLinks(links) {
    return links.map((link) => ({ link, ...parseLinkText(link.link) })).filter(({ subpath }) => subpath).filter(this.isLinkPathBroken).map(({ link, subpath }) => ({
      link,
      newPath: this.findFileWithSubpathInCache(subpath)
    })).reduce(
      (result, { link, newPath }) => {
        newPath ? result.fixable.push({ link, newPath }) : result.broken.push(link);
        return result;
      },
      { fixable: [], broken: [] }
    );
  }
  findFileWithSubpathInCache(subpath) {
    const found = Object.entries(this.app.metadataCache.fileCache).find(
      ([, { hash }]) => isSubpathInMetadata(subpath, this.app.metadataCache.metadataCache[hash])
    );
    if (!found) {
      return null;
    }
    const newPath = this.getFileFromPathRelativeToActiveFile(found[0]);
    (0, import_typed_assert.isNotNull)(
      newPath,
      "Metadata cache contained a path that has the required subpath but doesn't point to a file"
    );
    return this.app.metadataCache.fileToLinktext(
      newPath,
      this.getActiveFile().path
    );
  }
  getFileFromPathRelativeToActiveFile(path) {
    return this.app.metadataCache.getFirstLinkpathDest(
      path,
      this.getActiveFile().path
    );
  }
  getBacklinksForSourceFile() {
    (0, import_typed_assert.isNotVoid)(this.sourceFile);
    return this.app.metadataCache.getBacklinksForFile(this.sourceFile).data;
  }
  async redirectLinksToActiveFile(links) {
    return Promise.all(
      links.map(async ({ filePath, links: links2 }) => {
        const contents = await this.readFile(filePath);
        const activeFilePath = this.getPathToActiveFileFrom(filePath);
        const linksWithNewPath = links2.map((link) => ({
          link,
          newPath: activeFilePath
        }));
        const updatedContents = redirectLinksInTextToNewPaths(
          linksWithNewPath,
          contents
        );
        return this.updateFile(filePath, updatedContents);
      })
    );
  }
  runAfterMetadataUpdateIn(targetFile, action) {
    const callback = (file) => {
      if (file !== targetFile) {
        return;
      }
      try {
        action();
      } finally {
        this.app.metadataCache.off("changed", callback);
      }
    };
    this.app.metadataCache.on("changed", callback);
  }
  getFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    (0, import_typed_assert.isInstanceOf)(file, import_obsidian.TFile);
    return file;
  }
  async readFile(path) {
    return this.app.vault.read(this.getFile(path));
  }
  async updateFile(path, newContents) {
    return this.app.vault.modify(this.getFile(path), newContents);
  }
  getPathToActiveFileFrom(sourcePath) {
    return this.app.metadataCache.fileToLinktext(
      this.getActiveFile(),
      sourcePath
    );
  }
  getActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    (0, import_typed_assert.isNotNull)(activeFile);
    return activeFile;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3R5cGVkLWFzc2VydC9zcmMvaW5kZXgudHMiLCAic3JjL21haW4udHMiLCAic3JjL3BhdHRlcm5zLnRzIiwgInNyYy91dGlscy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiY29uc3QgZXhwZWN0ZWRUb0JlID0gKHR5cGU6IHN0cmluZyk6IHN0cmluZyA9PiBgZXhwZWN0ZWQgdG8gYmUgJHt0eXBlfWA7XG5cbmV4cG9ydCB0eXBlIFdlYWtBc3NlcnQgPSAoaW5wdXQ6IHVua25vd24sIG1lc3NhZ2U/OiBzdHJpbmcpID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFN1YlR5cGU8SW5wdXQsIE91dHB1dD4gPSBPdXRwdXQgZXh0ZW5kcyBJbnB1dCA/IE91dHB1dCA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBBc3NlcnQ8SW5wdXQgPSB1bmtub3duLCBPdXRwdXQgPSBJbnB1dD4gPSAoXG4gIGlucHV0OiBJbnB1dCxcbiAgbWVzc2FnZT86IHN0cmluZyxcbikgPT4gYXNzZXJ0cyBpbnB1dCBpcyBTdWJUeXBlPElucHV0LCBPdXRwdXQ+O1xuXG5leHBvcnQgdHlwZSBDaGVjazxJbnB1dCA9IHVua25vd24sIE91dHB1dCA9IElucHV0PiA9IChcbiAgaW5wdXQ6IElucHV0LFxuKSA9PiBpbnB1dCBpcyBTdWJUeXBlPElucHV0LCBPdXRwdXQ+O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdEFzc2VydDogV2Vha0Fzc2VydCA9IChjb25kaXRpb24sIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG5sZXQgYmFzZUFzc2VydCA9IGRlZmF1bHRBc3NlcnQ7XG5cbmV4cG9ydCBjb25zdCBhc3NlcnQ6IEFzc2VydDxib29sZWFuLCB0cnVlPiA9IChjb25kaXRpb24sIG1lc3NhZ2UpID0+XG4gIGJhc2VBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEJhc2VBc3NlcnQoYXNzZXJ0PzogV2Vha0Fzc2VydCk6IHZvaWQge1xuICBpZiAoYXNzZXJ0KSB7XG4gICAgYmFzZUFzc2VydCA9IGFzc2VydDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2FmZUpzb25QYXJzZSA9IChqc29uOiBzdHJpbmcpOiB1bmtub3duID0+XG4gIEpTT04ucGFyc2UoanNvbikgYXMgdW5rbm93bjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5rbm93bihfaW5wdXQ6IHVua25vd24pOiBfaW5wdXQgaXMgdW5rbm93biB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOZXZlcihcbiAgX2lucHV0OiBuZXZlcixcbiAgbWVzc2FnZTogc3RyaW5nID0gZXhwZWN0ZWRUb0JlKFwidW5yZWFjaGFibGVcIiksXG4pOiBuZXZlciB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm90TnVsbDxUPihcbiAgaW5wdXQ6IG51bGwgfCBULFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoXCJub3QgbnVsbFwiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgVCB7XG4gIGFzc2VydChpbnB1dCAhPT0gbnVsbCwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vdFVuZGVmaW5lZDxUPihcbiAgaW5wdXQ6IHVuZGVmaW5lZCB8IFQsXG4gIG1lc3NhZ2U6IHN0cmluZyA9IGV4cGVjdGVkVG9CZShcIm5vdCB1bmRlZmluZWRcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIFQge1xuICBhc3NlcnQoaW5wdXQgIT09IHVuZGVmaW5lZCwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc05vdFZvaWQ8VD4oXG4gIGlucHV0OiBULFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoXCJuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZFwiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgRXhjbHVkZTxULCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZD4ge1xuICBhc3NlcnQoaW5wdXQgIT09IG51bGwgJiYgaW5wdXQgIT09IHVuZGVmaW5lZCwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4YWN0bHk8SW5wdXQsIE91dHB1dD4oXG4gIGlucHV0OiBJbnB1dCxcbiAgdmFsdWU6IE91dHB1dCxcbiAgbWVzc2FnZSA9IGV4cGVjdGVkVG9CZShgZXhhY3RseSAke3ZhbHVlfWApLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyBTdWJUeXBlPElucHV0LCBPdXRwdXQ+IHtcbiAgYXNzZXJ0KChpbnB1dCBhcyB1bmtub3duKSA9PT0gKHZhbHVlIGFzIHVua25vd24pLCBtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbihcbiAgaW5wdXQ6IHVua25vd24sXG4gIG1lc3NhZ2U6IHN0cmluZyA9IGV4cGVjdGVkVG9CZShcImEgYm9vbGVhblwiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgYm9vbGVhbiB7XG4gIGFzc2VydCh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiLCBtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKFxuICBpbnB1dDogdW5rbm93bixcbiAgbWVzc2FnZTogc3RyaW5nID0gZXhwZWN0ZWRUb0JlKFwiYSBudW1iZXJcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIG51bWJlciB7XG4gIGFzc2VydCh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIsIG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoXG4gIGlucHV0OiB1bmtub3duLFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoXCJhIHN0cmluZ1wiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgc3RyaW5nIHtcbiAgYXNzZXJ0KHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUoXG4gIGlucHV0OiB1bmtub3duLFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoXCJhIERhdGVcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIERhdGUge1xuICBhc3NlcnQoaW5wdXQgaW5zdGFuY2VvZiBEYXRlLCBtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVjb3JkKFxuICBpbnB1dDogdW5rbm93bixcbiAgbWVzc2FnZTogc3RyaW5nID0gZXhwZWN0ZWRUb0JlKFwiYSByZWNvcmRcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgYXNzZXJ0KHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiwgbWVzc2FnZSk7XG4gIGlzTm90TnVsbChpbnB1dCwgbWVzc2FnZSk7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGlucHV0IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSkge1xuICAgIGlzU3RyaW5nKGtleSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVjb3JkV2l0aEtleXM8SyBleHRlbmRzIHN0cmluZz4oXG4gIGlucHV0OiB1bmtub3duLFxuICBrZXlzOiBLW10sXG4gIG1lc3NhZ2UgPSBleHBlY3RlZFRvQmUoYGEgcmVjb3JkIHdpdGgga2V5cyAke2tleXMuam9pbihcIiwgXCIpfWApLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyB7XG4gIHJlYWRvbmx5IFtLZXkgaW4gS106IHVua25vd247XG59IHtcbiAgaXNSZWNvcmQoaW5wdXQsIG1lc3NhZ2UpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaXNOb3RVbmRlZmluZWQoaW5wdXRba2V5XSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkoXG4gIGlucHV0OiB1bmtub3duLFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoXCJhbiBhcnJheVwiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgdW5rbm93bltdIHtcbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoaW5wdXQpLCBtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVjb3JkT2ZUeXBlPFQ+KFxuICBpbnB1dDogdW5rbm93bixcbiAgYXNzZXJ0VDogQXNzZXJ0PHVua25vd24sIFQ+LFxuICBtZXNzYWdlID0gZXhwZWN0ZWRUb0JlKFwiYSByZWNvcmQgb2YgZ2l2ZW4gdHlwZVwiKSxcbiAgaXRlbU1lc3NhZ2UgPSBleHBlY3RlZFRvQmUoXCJvZiBnaXZlbiB0eXBlXCIpLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyBSZWNvcmQ8c3RyaW5nLCBUPiB7XG4gIGlzUmVjb3JkKGlucHV0LCBtZXNzYWdlKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIE9iamVjdC52YWx1ZXMoaW5wdXQpKSB7XG4gICAgYXNzZXJ0VChpdGVtLCBpdGVtTWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlPZlR5cGU8VD4oXG4gIGlucHV0OiB1bmtub3duLFxuICBhc3NlcnRUOiBBc3NlcnQ8dW5rbm93biwgVD4sXG4gIG1lc3NhZ2UgPSBleHBlY3RlZFRvQmUoXCJhbiBhcnJheSBvZiBnaXZlbiB0eXBlXCIpLFxuICBpdGVtTWVzc2FnZSA9IGV4cGVjdGVkVG9CZShcIm9mIGdpdmVuIHR5cGVcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIFRbXSB7XG4gIGlzQXJyYXkoaW5wdXQsIG1lc3NhZ2UpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaW5wdXQpIHtcbiAgICBhc3NlcnRUKGl0ZW0sIGl0ZW1NZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPcHRpb25PZlR5cGU8SW5wdXQsIE91dHB1dD4oXG4gIGlucHV0OiBJbnB1dCB8IHVuZGVmaW5lZCxcbiAgYXNzZXJ0VDogQXNzZXJ0PElucHV0LCBPdXRwdXQ+LFxuICBtZXNzYWdlID0gZXhwZWN0ZWRUb0JlKFwib3B0aW9uIG9mIGdpdmVuIHR5cGVcIiksXG4pOiBhc3NlcnRzIGlucHV0IGlzIFN1YlR5cGU8SW5wdXQsIE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnRUKGlucHV0LCBtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT25lT2Y8SW5wdXQsIE91dHB1dD4oXG4gIGlucHV0OiBJbnB1dCxcbiAgdmFsdWVzOiByZWFkb25seSBPdXRwdXRbXSxcbiAgbWVzc2FnZTogc3RyaW5nID0gZXhwZWN0ZWRUb0JlKGBvbmUgb2YgJHt2YWx1ZXMuam9pbihcIiwgXCIpfWApLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyBTdWJUeXBlPElucHV0LCBPdXRwdXQ+IHtcbiAgYXNzZXJ0KHZhbHVlcy5pbmNsdWRlcyhpbnB1dCBhcyBTdWJUeXBlPElucHV0LCBPdXRwdXQ+KSwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09uZU9mVHlwZTxUPihcbiAgaW5wdXQ6IHVua25vd24sXG4gIGFzc2VydFQ6IEFzc2VydDx1bmtub3duLCBUPltdLFxuICBtZXNzYWdlOiBzdHJpbmcgPSBleHBlY3RlZFRvQmUoYG9uZSBvZiB0eXBlYCksXG4gIGl0ZW1NZXNzYWdlPzogc3RyaW5nLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyBUIHtcbiAgZm9yIChjb25zdCBhc3NlcnQgb2YgYXNzZXJ0VCkge1xuICAgIHRyeSB7XG4gICAgICAoYXNzZXJ0IGFzIFdlYWtBc3NlcnQpKGlucHV0IGFzIFQsIGl0ZW1NZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChfKSB7fVxuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luc3RhbmNlT2Y8VD4oXG4gIGlucHV0OiB1bmtub3duLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdHJ1Y3RvcjogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCxcbiAgbWVzc2FnZSA9IGV4cGVjdGVkVG9CZShcImFuIGluc3RhbmNlIG9mIGdpdmVuIGNvbnN0cnVjdG9yXCIpLFxuKTogYXNzZXJ0cyBpbnB1dCBpcyBUIHtcbiAgYXNzZXJ0KGlucHV0IGluc3RhbmNlb2YgY29uc3RydWN0b3IsIG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9taXNlKFxuICBpbnB1dDogdW5rbm93bixcbiAgbWVzc2FnZSA9IGV4cGVjdGVkVG9CZShcImEgcHJvbWlzZVwiKSxcbik6IGFzc2VydHMgaW5wdXQgaXMgUHJvbWlzZTx1bmtub3duPiB7XG4gIGlzSW5zdGFuY2VPZihpbnB1dCwgUHJvbWlzZSwgbWVzc2FnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVjazxJbnB1dCwgT3V0cHV0PihcbiAgYXNzZXJ0VDogQXNzZXJ0PElucHV0LCBPdXRwdXQ+LFxuKTogQ2hlY2s8SW5wdXQsIE91dHB1dD4ge1xuICByZXR1cm4gKGlucHV0OiBJbnB1dCk6IGlucHV0IGlzIFN1YlR5cGU8SW5wdXQsIE91dHB1dD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBhc3NlcnRUKGlucHV0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG4iLCAiaW1wb3J0IHsgRWRpdG9yLCBMaW5rQ2FjaGUsIE5vdGljZSwgUGx1Z2luLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBpc0luc3RhbmNlT2YsIGlzTm90TnVsbCwgaXNOb3RWb2lkIH0gZnJvbSBcInR5cGVkLWFzc2VydFwiO1xyXG5pbXBvcnQgeyBCcm9rZW5MaW5rUmVzdWx0IH0gZnJvbSBcIi4vdHlwZXNcIjtcclxuaW1wb3J0IHtcclxuICBjcmVhdGVSZXBhaXJOb3RpY2UsXHJcbiAgY3JlYXRlVXBkYXRlTm90aWNlLFxyXG4gIGZpbHRlckxpbmtzVG9JdGVtc1ByZXNlbnRJblRleHQsXHJcbiAgaXNTdWJwYXRoSW5NZXRhZGF0YSxcclxuICBwYXJzZUxpbmtUZXh0LFxyXG4gIHJlZGlyZWN0TGlua3NJblRleHRUb05ld1BhdGhzLFxyXG59IGZyb20gXCIuL3V0aWxzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZXJzaXN0ZW50TGlua3NQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG4gIHNvdXJjZUZpbGU6IFRGaWxlIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgYXN5bmMgb25sb2FkKCkge1xyXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcclxuICAgICAgaWQ6IFwicGVyc2lzdGVudC1saW5rczpyZXBhaXItbGlua3MtaW4tZmlsZVwiLFxyXG4gICAgICBuYW1lOiBcIlJlcGFpciBsaW5rcyBpbiBmaWxlXCIsXHJcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yKSA9PiB7XHJcbiAgICAgICAgdGhpcy5yZXBhaXJMaW5rc0luRmlsZShlZGl0b3IpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpO1xyXG4gICAgaXNOb3ROdWxsKGJvZHkpO1xyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJEb21FdmVudChib2R5LCBcImN1dFwiLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuc291cmNlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJlZGl0b3ItcGFzdGVcIiwgdGhpcy5oYW5kbGVFZGl0b3JQYXN0ZSk7XHJcbiAgfVxyXG5cclxuICBvbnVubG9hZCgpIHtcclxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vZmYoXCJlZGl0b3ItcGFzdGVcIiwgdGhpcy5oYW5kbGVFZGl0b3JQYXN0ZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlcGFpckxpbmtzSW5GaWxlKGVkaXRvcjogRWRpdG9yKSB7XHJcbiAgICBjb25zdCBhY3RpdmVGaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShcclxuICAgICAgdGhpcy5nZXRBY3RpdmVGaWxlKClcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFhY3RpdmVGaWxlQ2FjaGUpIHtcclxuICAgICAgbmV3IE5vdGljZShcIk5vdGhpbmcgdG8gZml4XCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBsaW5rcyA9IFtdLCBlbWJlZHMgPSBbXSB9ID0gYWN0aXZlRmlsZUNhY2hlO1xyXG5cclxuICAgIGNvbnN0IHsgZml4YWJsZSwgYnJva2VuIH0gPSB0aGlzLmZpbmROZXdQYXRoc0ZvckJyb2tlbkxpbmtzKFtcclxuICAgICAgLi4ubGlua3MsXHJcbiAgICAgIC4uLmVtYmVkcyxcclxuICAgIF0pO1xyXG5cclxuICAgIGlmIChmaXhhYmxlLmxlbmd0aCA+IDApIHtcclxuICAgICAgZWRpdG9yLnNldFZhbHVlKFxyXG4gICAgICAgIHJlZGlyZWN0TGlua3NJblRleHRUb05ld1BhdGhzKGZpeGFibGUsIGVkaXRvci5nZXRWYWx1ZSgpKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIG5ldyBOb3RpY2UoY3JlYXRlUmVwYWlyTm90aWNlKGZpeGFibGUubGVuZ3RoLCBicm9rZW4ubGVuZ3RoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZpbmROZXdQYXRoc0ZvckJyb2tlbkxpbmtzKGxpbmtzOiBMaW5rQ2FjaGVbXSkge1xyXG4gICAgcmV0dXJuIGxpbmtzXHJcbiAgICAgIC5tYXAoKGxpbmspID0+ICh7IGxpbmssIC4uLnBhcnNlTGlua1RleHQobGluay5saW5rKSB9KSlcclxuICAgICAgLmZpbHRlcigoeyBzdWJwYXRoIH0pID0+IHN1YnBhdGgpXHJcbiAgICAgIC5maWx0ZXIodGhpcy5pc0xpbmtQYXRoQnJva2VuKVxyXG4gICAgICAubWFwKCh7IGxpbmssIHN1YnBhdGggfSkgPT4gKHtcclxuICAgICAgICBsaW5rLFxyXG4gICAgICAgIG5ld1BhdGg6IHRoaXMuZmluZEZpbGVXaXRoU3VicGF0aEluQ2FjaGUoc3VicGF0aCksXHJcbiAgICAgIH0pKVxyXG4gICAgICAucmVkdWNlKFxyXG4gICAgICAgIChyZXN1bHQ6IEJyb2tlbkxpbmtSZXN1bHQsIHsgbGluaywgbmV3UGF0aCB9KSA9PiB7XHJcbiAgICAgICAgICBuZXdQYXRoXHJcbiAgICAgICAgICAgID8gcmVzdWx0LmZpeGFibGUucHVzaCh7IGxpbmssIG5ld1BhdGggfSlcclxuICAgICAgICAgICAgOiByZXN1bHQuYnJva2VuLnB1c2gobGluayk7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeyBmaXhhYmxlOiBbXSwgYnJva2VuOiBbXSB9XHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZpbmRGaWxlV2l0aFN1YnBhdGhJbkNhY2hlKHN1YnBhdGg6IHN0cmluZykge1xyXG4gICAgY29uc3QgZm91bmQgPSBPYmplY3QuZW50cmllcyh0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmZpbGVDYWNoZSkuZmluZChcclxuICAgICAgKFssIHsgaGFzaCB9XSkgPT5cclxuICAgICAgICBpc1N1YnBhdGhJbk1ldGFkYXRhKHN1YnBhdGgsIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUubWV0YWRhdGFDYWNoZVtoYXNoXSlcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdQYXRoID0gdGhpcy5nZXRGaWxlRnJvbVBhdGhSZWxhdGl2ZVRvQWN0aXZlRmlsZShmb3VuZFswXSk7XHJcblxyXG4gICAgaXNOb3ROdWxsKFxyXG4gICAgICBuZXdQYXRoLFxyXG4gICAgICBcIk1ldGFkYXRhIGNhY2hlIGNvbnRhaW5lZCBhIHBhdGggdGhhdCBoYXMgdGhlIHJlcXVpcmVkIHN1YnBhdGggYnV0IGRvZXNuJ3QgcG9pbnQgdG8gYSBmaWxlXCJcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZmlsZVRvTGlua3RleHQoXHJcbiAgICAgIG5ld1BhdGgsXHJcbiAgICAgIHRoaXMuZ2V0QWN0aXZlRmlsZSgpLnBhdGhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEZpbGVGcm9tUGF0aFJlbGF0aXZlVG9BY3RpdmVGaWxlKHBhdGg6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoXHJcbiAgICAgIHBhdGgsXHJcbiAgICAgIHRoaXMuZ2V0QWN0aXZlRmlsZSgpLnBhdGhcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzTGlua1BhdGhCcm9rZW4gPSAoe1xyXG4gICAgcGF0aCxcclxuICAgIHN1YnBhdGgsXHJcbiAgfToge1xyXG4gICAgcGF0aDogc3RyaW5nO1xyXG4gICAgc3VicGF0aDogc3RyaW5nO1xyXG4gIH0pID0+IHtcclxuICAgIGNvbnN0IHRvRmlsZSA9IHRoaXMuZ2V0RmlsZUZyb21QYXRoUmVsYXRpdmVUb0FjdGl2ZUZpbGUocGF0aCk7XHJcblxyXG4gICAgaWYgKHRvRmlsZSA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIWlzU3VicGF0aEluTWV0YWRhdGEoXHJcbiAgICAgIHN1YnBhdGgsXHJcbiAgICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRvRmlsZSlcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVFZGl0b3JQYXN0ZSA9IGFzeW5jIChldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IHtcclxuICAgIGlmICghdGhpcy5zb3VyY2VGaWxlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjbGlwYm9hcmRDb250ZW50cyA9IGV2ZW50Py5jbGlwYm9hcmREYXRhPy5nZXREYXRhKFwidGV4dFwiKTtcclxuXHJcbiAgICBpZiAoIWNsaXBib2FyZENvbnRlbnRzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBiYWNrbGlua3NUb1VwZGF0ZSA9IGZpbHRlckxpbmtzVG9JdGVtc1ByZXNlbnRJblRleHQoXHJcbiAgICAgIHRoaXMuZ2V0QmFja2xpbmtzRm9yU291cmNlRmlsZSgpLFxyXG4gICAgICBjbGlwYm9hcmRDb250ZW50c1xyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoYmFja2xpbmtzVG9VcGRhdGUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJ1bkFmdGVyTWV0YWRhdGFVcGRhdGVJbih0aGlzLmdldEFjdGl2ZUZpbGUoKSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCB0aGlzLnJlZGlyZWN0TGlua3NUb0FjdGl2ZUZpbGUoYmFja2xpbmtzVG9VcGRhdGUpO1xyXG5cclxuICAgICAgbmV3IE5vdGljZShjcmVhdGVVcGRhdGVOb3RpY2UoYmFja2xpbmtzVG9VcGRhdGUpKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgZ2V0QmFja2xpbmtzRm9yU291cmNlRmlsZSgpIHtcclxuICAgIGlzTm90Vm9pZCh0aGlzLnNvdXJjZUZpbGUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEJhY2tsaW5rc0ZvckZpbGUodGhpcy5zb3VyY2VGaWxlKS5kYXRhO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWRpcmVjdExpbmtzVG9BY3RpdmVGaWxlKFxyXG4gICAgbGlua3M6IEFycmF5PHsgZmlsZVBhdGg6IHN0cmluZzsgbGlua3M6IExpbmtDYWNoZVtdIH0+XHJcbiAgKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXHJcbiAgICAgIGxpbmtzLm1hcChhc3luYyAoeyBmaWxlUGF0aCwgbGlua3MgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5yZWFkRmlsZShmaWxlUGF0aCk7XHJcbiAgICAgICAgY29uc3QgYWN0aXZlRmlsZVBhdGggPSB0aGlzLmdldFBhdGhUb0FjdGl2ZUZpbGVGcm9tKGZpbGVQYXRoKTtcclxuICAgICAgICBjb25zdCBsaW5rc1dpdGhOZXdQYXRoID0gbGlua3MubWFwKChsaW5rKSA9PiAoe1xyXG4gICAgICAgICAgbGluayxcclxuICAgICAgICAgIG5ld1BhdGg6IGFjdGl2ZUZpbGVQYXRoLFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudHMgPSByZWRpcmVjdExpbmtzSW5UZXh0VG9OZXdQYXRocyhcclxuICAgICAgICAgIGxpbmtzV2l0aE5ld1BhdGgsXHJcbiAgICAgICAgICBjb250ZW50c1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZpbGUoZmlsZVBhdGgsIHVwZGF0ZWRDb250ZW50cyk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBydW5BZnRlck1ldGFkYXRhVXBkYXRlSW4odGFyZ2V0RmlsZTogVEZpbGUsIGFjdGlvbjogKCkgPT4gdm9pZCkge1xyXG4gICAgY29uc3QgY2FsbGJhY2sgPSAoZmlsZTogVEZpbGUpID0+IHtcclxuICAgICAgaWYgKGZpbGUgIT09IHRhcmdldEZpbGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vZmYoXCJjaGFuZ2VkXCIsIGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKFwiY2hhbmdlZFwiLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEZpbGUocGF0aDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpO1xyXG4gICAgaXNJbnN0YW5jZU9mKGZpbGUsIFRGaWxlKTtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWFkRmlsZShwYXRoOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLmFwcC52YXVsdC5yZWFkKHRoaXMuZ2V0RmlsZShwYXRoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHVwZGF0ZUZpbGUocGF0aDogc3RyaW5nLCBuZXdDb250ZW50czogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hcHAudmF1bHQubW9kaWZ5KHRoaXMuZ2V0RmlsZShwYXRoKSwgbmV3Q29udGVudHMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRQYXRoVG9BY3RpdmVGaWxlRnJvbShzb3VyY2VQYXRoOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmZpbGVUb0xpbmt0ZXh0KFxyXG4gICAgICB0aGlzLmdldEFjdGl2ZUZpbGUoKSxcclxuICAgICAgc291cmNlUGF0aFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0QWN0aXZlRmlsZSgpIHtcclxuICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG4gICAgaXNOb3ROdWxsKGFjdGl2ZUZpbGUpO1xyXG4gICAgcmV0dXJuIGFjdGl2ZUZpbGU7XHJcbiAgfVxyXG59XHJcbiIsICJleHBvcnQgY29uc3QgSEVBRElORyA9IC9eIytcXHMuKyQvZ207XG5leHBvcnQgY29uc3QgQkxPQ0tfSUQgPSAvXFxzKyhcXF5bYS16QS1aMC05LV0rKSQvZ207XG5leHBvcnQgY29uc3QgTk9UX0xFVFRFUl9PUl9OVU1CRVIgPSAvW15cXHB7TGV0dGVyfVxccHtOdW1iZXJ9XS9ndTtcbmV4cG9ydCBjb25zdCBGSUxFX1BBVEhfSU5fTElOSyA9IC8oXFxbXFxbKS4qKCMpLztcblxuIiwgImltcG9ydCB7XHJcbiAgQkxPQ0tfSUQsXHJcbiAgRklMRV9QQVRIX0lOX0xJTkssXHJcbiAgSEVBRElORyxcclxuICBOT1RfTEVUVEVSX09SX05VTUJFUixcclxufSBmcm9tIFwiLi9wYXR0ZXJuc1wiO1xyXG5pbXBvcnQgeyBMaW5rV2l0aERlc3RpbmF0aW9uLCBQYXRoc1dpdGhMaW5rcyB9IGZyb20gXCIuL3R5cGVzXCI7XHJcbmltcG9ydCAqIGFzIG9ic2lkaWFuIGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBDYWNoZWRNZXRhZGF0YSwgSGVhZGluZ0NhY2hlLCBMaW5rQ2FjaGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCbG9ja0lkcyh0ZXh0OiBzdHJpbmcpIHtcclxuICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoQkxPQ0tfSUQpXS5tYXAoKG1hdGNoKSA9PiBtYXRjaFsxXSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWFkaW5ncyh0ZXh0OiBzdHJpbmcpIHtcclxuICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoSEVBRElORyldLm1hcCgobWF0Y2gpID0+IG1hdGNoWzBdKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRpbmcodGV4dDogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHRleHQucmVwbGFjZUFsbChOT1RfTEVUVEVSX09SX05VTUJFUiwgXCJcIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROb3JtYWxpemVkSGVhZGluZ0luTGluayhsaW5rOiBzdHJpbmcpIHtcclxuICBjb25zdCBoZWFkaW5nUGFydCA9IGxpbmsuc3BsaXQoXCIjXCIpWzFdO1xyXG4gIGlmIChoZWFkaW5nUGFydCkge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUhlYWRpbmcoaGVhZGluZ1BhcnQpO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTGlua1RleHQobGlua1RleHQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHsgcGF0aCwgc3VicGF0aCB9ID0gb2JzaWRpYW4ucGFyc2VMaW5rdGV4dChsaW5rVGV4dCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBhdGgsXHJcbiAgICBzdWJwYXRoOiBzdHJpcFN1YnBhdGhUb2tlbihzdWJwYXRoKSxcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBTdWJwYXRoVG9rZW4oc3VicGF0aDogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHN1YnBhdGgucmVwbGFjZSgvI1xcXj8vLCBcIlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VGaWxlUGF0aEluTGluayhsaW5rOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZykge1xyXG4gIHJldHVybiBsaW5rLnJlcGxhY2UoRklMRV9QQVRIX0lOX0xJTkssIGAkMSR7bmV3UGF0aH0kMmApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyTGlua3NUb0l0ZW1zUHJlc2VudEluVGV4dChcclxuICBsaW5rczogUGF0aHNXaXRoTGlua3MsXHJcbiAgdGV4dDogc3RyaW5nXHJcbikge1xyXG4gIGNvbnN0IGJsb2NrSWRzSW5UZXh0ID0gZ2V0QmxvY2tJZHModGV4dCk7XHJcbiAgY29uc3QgaGVhZGluZ3NJblRleHQgPSBnZXRIZWFkaW5ncyh0ZXh0KTtcclxuXHJcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGxpbmtzKVxyXG4gICAgLm1hcCgoW2ZpbGVQYXRoLCBsaW5rc10pID0+ICh7XHJcbiAgICAgIGZpbGVQYXRoLFxyXG4gICAgICBsaW5rczogbGlua3MuZmlsdGVyKFxyXG4gICAgICAgICh7IGxpbms6IGxpbmtUZXh0IH06IExpbmtDYWNoZSkgPT5cclxuICAgICAgICAgIGJsb2NrSWRzSW5UZXh0LnNvbWUoKGlkKSA9PiBsaW5rVGV4dC5pbmNsdWRlcyhpZCkpIHx8XHJcbiAgICAgICAgICBoZWFkaW5nc0luVGV4dC5zb21lKFxyXG4gICAgICAgICAgICAoaGVhZGluZykgPT5cclxuICAgICAgICAgICAgICBnZXROb3JtYWxpemVkSGVhZGluZ0luTGluayhsaW5rVGV4dCkgPT09IG5vcm1hbGl6ZUhlYWRpbmcoaGVhZGluZylcclxuICAgICAgICAgIClcclxuICAgICAgKSxcclxuICAgIH0pKVxyXG4gICAgLmZpbHRlcigoeyBsaW5rcyB9KSA9PiBsaW5rcy5sZW5ndGggPiAwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZGlyZWN0TGlua3NJblRleHRUb05ld1BhdGhzKFxyXG4gIGxpbmtzV2l0aFBhdGhzOiBMaW5rV2l0aERlc3RpbmF0aW9uW10sXHJcbiAgdGV4dDogc3RyaW5nXHJcbikge1xyXG4gIHJldHVybiBsaW5rc1dpdGhQYXRoc1xyXG4gICAgLnNsaWNlKClcclxuICAgIC5zb3J0KChhLCBiKSA9PiBjb21wYXJlTGlua09mZnNldHMoYS5saW5rLCBiLmxpbmspKVxyXG4gICAgLnJldmVyc2UoKVxyXG4gICAgLnJlZHVjZShcclxuICAgICAgKHVwZGF0ZWRUZXh0OiBzdHJpbmcsIHsgbmV3UGF0aCwgbGluazogeyBwb3NpdGlvbiwgb3JpZ2luYWwgfSB9KSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbi5zdGFydC5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgZW5kID0gcG9zaXRpb24uZW5kLm9mZnNldDtcclxuXHJcbiAgICAgICAgY29uc3QgdXBkYXRlZExpbmsgPSByZXBsYWNlRmlsZVBhdGhJbkxpbmsob3JpZ2luYWwsIG5ld1BhdGgpO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgdXBkYXRlZFRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0KSArXHJcbiAgICAgICAgICB1cGRhdGVkTGluayArXHJcbiAgICAgICAgICB1cGRhdGVkVGV4dC5zdWJzdHJpbmcoZW5kKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRleHRcclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVVcGRhdGVOb3RpY2UoXHJcbiAgcmVzdWx0czogQXJyYXk8eyBmaWxlUGF0aDogc3RyaW5nOyBsaW5rczogTGlua0NhY2hlW10gfT5cclxuKSB7XHJcbiAgY29uc3QgZmlsZUNvdW50ID0gcmVzdWx0cy5sZW5ndGg7XHJcbiAgY29uc3QgbGlua0NvdW50ID0gcmVzdWx0cy5mbGF0TWFwKChmKSA9PiBmLmxpbmtzKS5sZW5ndGg7XHJcblxyXG4gIHJldHVybiBgVXBkYXRlZCAke2xpbmtDb3VudH0gbGlua3MgaW4gJHtmaWxlQ291bnR9IGZpbGVzYDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlcGFpck5vdGljZShmaXhlZDogbnVtYmVyLCBicm9rZW46IG51bWJlcikge1xyXG4gIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gIGlmIChmaXhlZCA+IDApIHtcclxuICAgIHJlc3VsdCArPSBgRml4ZWQgJHtmaXhlZH0gbGlua3NgO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJyb2tlbiA+IDApIHtcclxuICAgIHJlc3VsdCArPSBgXFxuQ291bGQgbm90IGZpeCAke2Jyb2tlbn0gbGlua3NgO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUxpbmtPZmZzZXRzKGxlZnQ6IExpbmtDYWNoZSwgcmlnaHQ6IExpbmtDYWNoZSkge1xyXG4gIHJldHVybiBsZWZ0LnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCAtIHJpZ2h0LnBvc2l0aW9uLnN0YXJ0Lm9mZnNldDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU3VicGF0aEluTWV0YWRhdGEoXHJcbiAgc3VicGF0aDogc3RyaW5nLFxyXG4gIG1ldGFkYXRhOiBDYWNoZWRNZXRhZGF0YSB8IG51bGwgfCB1bmRlZmluZWRcclxuKSB7XHJcbiAgaWYgKCFtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBibG9ja3MsIGhlYWRpbmdzIH0gPSBtZXRhZGF0YTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIChibG9ja3MgJiYgc3VicGF0aCBpbiBibG9ja3MpIHx8XHJcbiAgICAoaGVhZGluZ3MgJiYgaXNTdWJwYXRoSW5IZWFkaW5nQ2FjaGUoc3VicGF0aCwgaGVhZGluZ3MpKVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3VicGF0aEluSGVhZGluZ0NhY2hlKFxyXG4gIHN1YnBhdGg6IHN0cmluZyxcclxuICBoZWFkaW5nQ2FjaGU6IEhlYWRpbmdDYWNoZVtdXHJcbikge1xyXG4gIHJldHVybiBoZWFkaW5nQ2FjaGUuc29tZShcclxuICAgICh7IGhlYWRpbmcgfSkgPT4gbm9ybWFsaXplSGVhZGluZyhoZWFkaW5nKSA9PT0gbm9ybWFsaXplSGVhZGluZyhzdWJwYXRoKVxyXG4gICk7XHJcbn1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFFBQU0sZUFBZSxDQUFDLFNBQXlCLGtCQUFrQjtBQWUxRCxRQUFNLGdCQUE0QixDQUFDLFdBQVcsWUFBVztBQUM5RCxVQUFJLENBQUMsV0FBVztBQUNkLGNBQU0sSUFBSSxVQUFVLE9BQU87O0lBRS9CO0FBSmEsWUFBQSxnQkFBYTtBQU0xQixRQUFJLGFBQWEsUUFBQTtBQUVWLFFBQU0sU0FBZ0Ms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QWM7QUFDNUIsVUFBTSxPQUFPLEtBQUssSUFBSSxNQUFNLHNCQUFzQixJQUFJO0FBQ3RELDBDQUFhLE1BQU0scUJBQUs7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQWMsU0FBUyxNQUFjO0FBQ25DLFdBQU8sS0FBSyxJQUFJLE1BQU0sS0FBSyxLQUFLLFFBQVEsSUFBSSxDQUFDO0FBQUEsRUFDL0M7QUFBQSxFQUVBLE1BQWMsV0FBVyxNQUFjLGFBQXFCO0FBQzFELFdBQU8sS0FBSyxJQUFJLE1BQU0sT0FBTyxLQUFLLFFBQVEsSUFBSSxHQUFHLFdBQVc7QUFBQSxFQUM5RDtBQUFBLEVBRVEsd0JBQXdCLFlBQW9CO0FBQ2xELFdBQU8sS0FBSyxJQUFJLGNBQWM7QUFBQSxNQUM1QixLQUFLLGNBQWM7QUFBQSxNQUNuQjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFUSxnQkFBZ0I7QUFDdEIsVUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVLGNBQWM7QUFDcEQsdUNBQVUsVUFBVTtBQUNwQixXQUFPO0FBQUEsRUFDVDtBQUNGOyIsCiAgIm5hbWVzIjogWyJhc3NlcnQiLCAiaXNOb3ROdWxsIiwgImlzTm90Vm9pZCIsICJpc0luc3RhbmNlT2YiLCAibGlua3MiLCAibGlua3MiXQp9Cg==
