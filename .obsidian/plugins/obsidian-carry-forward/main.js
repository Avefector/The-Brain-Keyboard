/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => CarryForwardPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  linkText: "",
  copiedLinkText: "(see {{LINK}})",
  lineFormatFrom: "\\s*$",
  lineFormatTo: " (see {{LINK}})",
  removeLeadingWhitespace: true,
  displayCopiedNotice: true
};
var genID = (length = 5) => {
  const characters = "abcdefghijklmnopqrstuvwxyz-0123456789";
  let id = "";
  while (id.length < length) {
    id += characters[Math.floor(Math.random() * characters.length)];
  }
  return id.slice(0, length);
};
var CopyTypes;
(function(CopyTypes2) {
  CopyTypes2[CopyTypes2["SeparateLines"] = 0] = "SeparateLines";
  CopyTypes2[CopyTypes2["CombinedLines"] = 1] = "CombinedLines";
  CopyTypes2[CopyTypes2["LinkOnly"] = 2] = "LinkOnly";
  CopyTypes2[CopyTypes2["LinkOnlyEmbed"] = 3] = "LinkOnlyEmbed";
})(CopyTypes || (CopyTypes = {}));
var Mode;
(function(Mode2) {
  Mode2[Mode2["LinkTextFromSettings"] = 0] = "LinkTextFromSettings";
  Mode2[Mode2["LinkTextFromSelection"] = 1] = "LinkTextFromSelection";
  Mode2[Mode2["LinkTextFromClipboard"] = 2] = "LinkTextFromClipboard";
})(Mode || (Mode = {}));
var blockIDRegex = /(?:^| +)(?<blockID>\^[a-zA-Z0-9-]+)$/u;
var copyForwardLines = (editor, view, settings, copy = 0, mode = 0) => __async(void 0, null, function* () {
  var _a, _b, _c, _d;
  const regexValidation = validateRegex(settings.lineFormatFrom);
  if (regexValidation.valid !== true) {
    new import_obsidian.Notice(`Error: 'From' setting is invalid:

${regexValidation.string}

Please update the Carry-Forward settings and try again.`, 1e3 * 30);
    return;
  }
  const selections = editor.listSelections();
  const transaction = {
    changes: []
  };
  const copiedLines = [];
  const file = view.file;
  for (const selection of selections) {
    const cursorFrom = selection.anchor;
    const cursorTo = selection.head;
    const minLine = Math.min(cursorFrom.line, cursorTo.line);
    const maxLine = Math.max(cursorFrom.line, cursorTo.line);
    const maxLineLength = editor.getLine(maxLine).length;
    const updatedLines = [];
    let newID = "";
    for (let lineNumber = minLine; lineNumber <= maxLine; lineNumber++) {
      let line = editor.getLine(lineNumber);
      let copiedLine = line;
      if (settings.removeLeadingWhitespace === true && lineNumber === minLine && cursorFrom.ch === cursorTo.ch) {
        copiedLine = copiedLine.replace(/^\s*/, "");
      }
      if (selections.length > 1 && (lineNumber === minLine || lineNumber === maxLine) && !(minLine === maxLine && cursorFrom.ch === cursorTo.ch) || selections.length === 1 && minLine === maxLine && cursorFrom.ch !== cursorTo.ch) {
        copiedLine = line.slice(lineNumber === minLine ? Math.min(cursorFrom.ch, cursorTo.ch) : 0, lineNumber === maxLine ? Math.max(cursorFrom.ch, cursorTo.ch) : line.length - 1);
      }
      if (editor.getLine(lineNumber).match(/^\s*$/) && !(lineNumber === minLine && minLine === maxLine)) {
        copiedLines.push(copiedLine);
        updatedLines.push(line);
        continue;
      }
      let linkText = settings.linkText;
      if (mode === 1) {
        linkText = editor.getRange(selection.anchor, selection.head);
      }
      if (mode === 2) {
        linkText = yield navigator.clipboard.readText();
      }
      if (copy === 0 || lineNumber === minLine) {
        const blockIDMatch = (_a = line.match(blockIDRegex)) == null ? void 0 : _a.groups.blockID;
        let blockID = blockIDMatch === void 0 ? null : String(blockIDMatch);
        let link = "";
        const newChangeBlockIDs = (_b = transaction.changes) == null ? void 0 : _b.filter((change) => change.from.line === minLine && change.from.ch === 0 && change.to.line === maxLine && change.to.ch === maxLineLength);
        let newChangeBlockID = null;
        if (newChangeBlockIDs.length > 0) {
          newChangeBlockID = String((_c = newChangeBlockIDs[0].text.match(blockIDRegex)) == null ? void 0 : _c.groups.blockID);
        }
        if (blockID === null && newChangeBlockID === null) {
          newID = `^${genID()}`;
          link = view.app.fileManager.generateMarkdownLink(file, "/", `#${newID}`, linkText);
          line = line.replace(/\s*?$/, ` ${newID}`);
          if (copy === 2 || copy === 3) {
            link = (copy === 3 ? "!" : "") + link;
            copiedLine = copy === 3 ? link : settings.copiedLinkText.replace("{{LINK}}", link);
          } else {
            copiedLine = copiedLine.replace(new RegExp(settings.lineFormatFrom, "u"), settings.lineFormatTo.replace("{{LINK}}", link));
          }
        } else {
          if (blockID === null) {
            blockID = newChangeBlockID;
          }
          link = view.app.fileManager.generateMarkdownLink(file, "/", `#${blockID}`, linkText);
          if (copy === 2 || copy === 3) {
            link = (copy === 3 ? "!" : "") + link;
            copiedLine = copy === 3 ? link : settings.copiedLinkText.replace("{{LINK}}", link);
          } else {
            copiedLine = copiedLine.replace(blockIDRegex, "").replace(new RegExp(settings.lineFormatFrom, "u"), settings.lineFormatTo.replace("{{LINK}}", link));
          }
        }
      }
      if (!((copy === 2 || copy === 3) && lineNumber !== minLine)) {
        copiedLines.push(copiedLine);
      }
      updatedLines.push(line);
    }
    if (transaction.changes.filter((change) => change.from.line === minLine && change.from.ch === 0 && change.to.line === maxLine && change.to.ch === maxLineLength).length === 0) {
      (_d = transaction.changes) == null ? void 0 : _d.push({
        from: { line: minLine, ch: 0 },
        to: { line: maxLine, ch: maxLineLength },
        text: updatedLines.join("\n")
      });
    }
  }
  yield navigator.clipboard.writeText(copiedLines.join("\n"));
  if (settings.displayCopiedNotice || false) {
    new import_obsidian.Notice("Copied");
  }
  transaction.selections = selections.map((selection) => {
    return { from: selection.anchor, to: selection.head };
  });
  editor.transaction(transaction);
});
var CarryForwardPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("loading carry-forward-line plugin");
      yield this.loadSettings();
      this.addCommand({
        id: "carry-line-forward-separate-lines",
        icon: "pin",
        name: "Copy selection with each line linked to its copied source (default link text)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 0);
        })
      });
      this.addCommand({
        id: "carry-line-forward-combined-lines",
        icon: "pin",
        name: "Copy selection with first line linked to its copied source (default link text)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 1);
        })
      });
      this.addCommand({
        id: "carry-line-forward-link-only",
        icon: "pin",
        name: "Copy link to line (default link text)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 2);
        })
      });
      this.addCommand({
        id: "carry-line-forward-embed-link-only",
        icon: "pin",
        name: "Copy embed link to line (default link text)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 3);
        })
      });
      this.addCommand({
        id: "carry-line-forward-separate-lines-selection",
        icon: "pin",
        name: "Copy selection with each line linked to its copied source (link text from selection)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 0, 1);
        })
      });
      this.addCommand({
        id: "carry-line-forward-combined-lines-selection",
        icon: "pin",
        name: "Copy selection with first line linked to its copied source (link text from selection)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 1, 1);
        })
      });
      this.addCommand({
        id: "carry-line-forward-link-only-selection",
        icon: "pin",
        name: "Copy link to line (link text from selection)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 2, 1);
        })
      });
      this.addCommand({
        id: "carry-line-forward-embed-link-only-selection",
        icon: "pin",
        name: "Copy embed link to line (link text from selection)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 3, 1);
        })
      });
      this.addCommand({
        id: "carry-line-forward-separate-lines-clipboard",
        icon: "pin",
        name: "Copy selection with each line linked to its copied source (link text from clipboard)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 0, 2);
        })
      });
      this.addCommand({
        id: "carry-line-forward-combined-lines-clipboard",
        icon: "pin",
        name: "Copy selection with first line linked to its copied source (link text from clipboard)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 1, 2);
        })
      });
      this.addCommand({
        id: "carry-line-forward-link-only-clipboard",
        icon: "pin",
        name: "Copy link to line (link text from clipboard)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 2, 2);
        })
      });
      this.addCommand({
        id: "carry-line-forward-embed-link-only-clipboard",
        icon: "pin",
        name: "Copy embed link to line (link text from clipboard)",
        editorCallback: (editor, view) => __async(this, null, function* () {
          return yield copyForwardLines(editor, view, this.settings, 3, 2);
        })
      });
      this.addSettingTab(new CarryForwardSettingTab(this.app, this));
    });
  }
  onunload() {
    console.log("unloading carry-forward-line plugin");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var validateRegex = (regexString) => {
  let updatedRegexString = regexString.replace(/\\n/g, "\n").replace(/\\t/g, "	").replace(/\\r/g, "\r");
  try {
    new RegExp(updatedRegexString, "u");
    return { valid: true, string: updatedRegexString };
  } catch (e) {
    return {
      valid: false,
      string: `"${updatedRegexString}": "${e}"`
    };
  }
};
var CarryForwardSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Carry-forward" });
    new import_obsidian.Setting(containerEl).setName("Default link text").setDesc('The default text that "{{LINK}}" in the settings below will be replaced with. Leaving this blank will display the actual text of the link.').addText((text) => {
      const settings = this.plugin.settings;
      text.setValue(settings.linkText).onChange((value) => __async(this, null, function* () {
        settings.linkText = value;
        yield this.plugin.saveSettings();
      }));
    });
    const copiedLinksEl = containerEl.createEl("div");
    copiedLinksEl.createEl("h2", { text: "Copied references" });
    copiedLinksEl.createEl("p", {
      text: 'Settings relating to "Copy link to line..." and "Copy embed link to line..." commands.',
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(copiedLinksEl).setName("Copied references").setDesc("The full text of copied references. Use {{LINK}} to place the link.").addText((text) => {
      const settings = this.plugin.settings;
      text.setValue(settings.copiedLinkText).onChange((value) => __async(this, null, function* () {
        settings.copiedLinkText = value;
        yield this.plugin.saveSettings();
      }));
    });
    const copiedLinesEl = containerEl.createEl("div");
    copiedLinesEl.createEl("h2", { text: "Copied lines" });
    copiedLinesEl.createEl("p", {
      text: 'Settings relating to "Copy selection..." commands.',
      cls: "setting-item-description"
    });
    const fromToEl = copiedLinesEl.createEl("div");
    fromToEl.addClass("from-to-rule");
    if (validateRegex(this.plugin.settings.lineFormatFrom).valid !== true) {
      fromToEl.addClass("invalid");
    }
    new import_obsidian.Setting(fromToEl).setName("From").setDesc("Find the first match of a Regular Expression in each copied line").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.lineFormatFrom).setValue(this.plugin.settings.lineFormatFrom).onChange((value) => __async(this, null, function* () {
      if (value === "") {
        this.plugin.settings.lineFormatFrom = DEFAULT_SETTINGS.lineFormatFrom;
      } else {
        if (validateRegex(value).valid !== true) {
          fromToEl.addClass("invalid");
        } else {
          fromToEl.removeClass("invalid");
        }
        this.plugin.settings.lineFormatFrom = value;
      }
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(fromToEl).setName("To").setDesc("Replace the first match in each copied line with text. Use {{LINK}} to place the link.").addText((text) => text.setPlaceholder(DEFAULT_SETTINGS.lineFormatTo).setValue(this.plugin.settings.lineFormatTo).onChange((value) => __async(this, null, function* () {
      if (value === "") {
        this.plugin.settings.lineFormatTo = DEFAULT_SETTINGS.lineFormatTo;
      } else {
        this.plugin.settings.lineFormatTo = value;
      }
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(copiedLinesEl).setName("Remove leading whitespace from first line").setDesc("When copying a line without having selected a specific part of that line, remove any whitespace at the beginning of the copied line.").addToggle((toggle) => {
      const settings = this.plugin.settings;
      toggle.setValue(settings.removeLeadingWhitespace).onChange((value) => __async(this, null, function* () {
        settings.removeLeadingWhitespace = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Notify on successful copy").setDesc('Display a "Copied" notice upon successfully copying text to the clipboard.').addToggle((toggle) => {
      const settings = this.plugin.settings;
      toggle.setValue(settings.displayCopiedNotice).onChange((value) => __async(this, null, function* () {
        settings.displayCopiedNotice = value;
        yield this.plugin.saveSettings();
      }));
    });
  }
};
