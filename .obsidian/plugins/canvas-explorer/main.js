/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  canvasFolder: "",
  nodeWidth: 400,
  nodeHeight: 600,
  sortProperty: "created_at",
  excludedSections: ""
};
var MyPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Canvas Folder").setDesc("Select the folder to save canvases").addText((text) => text.setPlaceholder("Example: Folder/Subfolder").setValue(this.plugin.settings.canvasFolder).onChange(async (value) => {
      this.plugin.settings.canvasFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Node Width").setDesc("Specify the width of nodes in the canvas (in pixels)").addText((text) => text.setPlaceholder("400").setValue(String(this.plugin.settings.nodeWidth)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.nodeWidth = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Node Height").setDesc("Specify the height of nodes in the canvas (in pixels)").addText((text) => text.setPlaceholder("600").setValue(String(this.plugin.settings.nodeHeight)).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.nodeHeight = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Sort Property").setDesc("Specify the frontmatter property to use for sorting notes. If left empty or property not found, file creation date will be used.").addText((text) => text.setPlaceholder("e.g. created_at").setValue(this.plugin.settings.sortProperty).onChange(async (value) => {
      this.plugin.settings.sortProperty = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded Sections").setDesc("Specify section titles to exclude from concatenation (comma-separated)").addText((text) => text.setPlaceholder("e.g. Do not include, Private notes").setValue(this.plugin.settings.excludedSections).onChange(async (value) => {
      this.plugin.settings.excludedSections = value;
      await this.plugin.saveSettings();
    }));
  }
};
var MyPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.stack = [];
    this.preservedNotes = [];
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new MyPluginSettingTab(this.app, this));
    this.addCommand({
      id: "add-note",
      name: "Add Note",
      callback: () => this.addNote()
    });
    this.addCommand({
      id: "ignore-note",
      name: "Ignore Note",
      callback: () => this.ignoreNote()
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async addNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      await this.preserveNote(activeFile);
    }
  }
  async ignoreNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      await this.discardNote(activeFile);
    }
  }
  async preserveNote(file) {
    if (!this.preservedNotes.includes(file)) {
      this.preservedNotes.push(file);
      const linkedFiles = await this.getLinksAndBacklinks(file);
      for (const linkedFile of linkedFiles) {
        if (!this.stack.includes(linkedFile) && !this.preservedNotes.includes(linkedFile)) {
          this.stack.push(linkedFile);
        }
      }
    }
    new import_obsidian.Notice(`${this.stack.length} notes left to process.`);
    this.processNextNote();
  }
  async discardNote(file) {
    this.processNextNote();
  }
  async getLinksAndBacklinks(file) {
    var _a;
    const linkedFiles = [];
    const links = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.links) || [];
    const backlinks = this.app.metadataCache.getBacklinksForFile(file);
    for (const link of links) {
      const linkedFilePath = this.app.metadataCache.getFirstLinkpathDest(link.link, file.path);
      if (linkedFilePath) {
        const linkedFile = this.app.vault.getAbstractFileByPath(linkedFilePath.path);
        if (linkedFile instanceof import_obsidian.TFile) {
          linkedFiles.push(linkedFile);
        }
      }
    }
    if (backlinks && backlinks.data) {
      const backlinkData = backlinks.data;
      for (const backlinkPath of backlinkData.keys()) {
        const backlinkFile = this.app.vault.getAbstractFileByPath(backlinkPath);
        if (backlinkFile instanceof import_obsidian.TFile) {
          linkedFiles.push(backlinkFile);
        }
      }
    }
    return linkedFiles;
  }
  async processNextNote() {
    if (this.stack.length > 0) {
      const nextFile = this.stack.shift();
      if (nextFile) {
        await this.app.workspace.getLeaf().openFile(nextFile);
      }
    } else {
      const fileName = await this.getFileNameFromModal();
      if (fileName) {
        await this.createAndDisplayCanvas(fileName, this.app.workspace.getLeaf());
      }
      this.resetPlugin();
    }
  }
  async getFileNameFromModal() {
    return new Promise((resolve) => {
      new FileNameModal(this.app, resolve).open();
    });
  }
  async createAndDisplayCanvas(fileName, leaf) {
    const canvasContent = await this.generateCanvasContent();
    const fullFileName = `${fileName}.canvas`;
    let filePath = fullFileName;
    if (this.settings.canvasFolder) {
      filePath = `${this.settings.canvasFolder}/${fullFileName}`;
      const folderExists = await this.app.vault.adapter.exists(this.settings.canvasFolder);
      if (!folderExists) {
        try {
          await this.app.vault.adapter.mkdir(this.settings.canvasFolder);
        } catch (error) {
          new import_obsidian.Notice(`Error creating folder: ${error.message}`);
          return;
        }
      }
    }
    try {
      const canvasFile = await this.app.vault.create(filePath, canvasContent);
      await leaf.openFile(canvasFile);
    } catch (error) {
      new import_obsidian.Notice(`Error creating canvas: ${error.message}`);
    }
  }
  async readFileContent(file) {
    try {
      return await this.app.vault.read(file);
    } catch (error) {
      console.error(`Erreur lors de la lecture du fichier ${file.path}:`, error);
      return "";
    }
  }
  async generateCanvasContent() {
    const nodes = [];
    const edges = [];
    const noteCount = this.preservedNotes.length;
    const columns = Math.ceil(Math.sqrt(noteCount));
    const nodeWidth = this.settings.nodeWidth;
    const nodeHeight = this.settings.nodeHeight;
    const spacingX = 40;
    const spacingY = 40;
    const connectionCounts = /* @__PURE__ */ new Map();
    for (const file of this.preservedNotes) {
      const linkedFiles = await this.getLinksAndBacklinks(file);
      connectionCounts.set(file, linkedFiles.length);
    }
    const sortedNotes = this.preservedNotes.sort((a, b) => {
      const valueA = this.getPropertyValue(a, this.settings.sortProperty);
      const valueB = this.getPropertyValue(b, this.settings.sortProperty);
      return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
    });
    const notesByConnections = [...this.preservedNotes].sort(
      (a, b) => (connectionCounts.get(b) || 0) - (connectionCounts.get(a) || 0)
    );
    const colors = ["#FF0000", "#FFA500", "#FFFF00", "#8A2BE2", "#0000FF"];
    const getColorForNote = (file) => {
      const index = notesByConnections.indexOf(file);
      const percentile = index / notesByConnections.length;
      const colorIndex = Math.min(Math.floor(percentile * 5), 4);
      return colors[colorIndex];
    };
    const excludedSections = this.settings.excludedSections.split(",").map((section) => section.trim()).filter((section) => section.length > 0);
    const excludeSections = (content) => {
      const lines = content.split("\n");
      let result = "";
      let excluding = false;
      let currentLevel = 0;
      for (const line of lines) {
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
          const level = match[1].length;
          const title = match[2];
          if (excludedSections.includes(title)) {
            excluding = true;
            currentLevel = level;
          } else if (level <= currentLevel) {
            excluding = false;
          }
        }
        if (!excluding) {
          result += line + "\n";
        }
      }
      return result.trim();
    };
    let concatenatedContent = "";
    for (const file of sortedNotes) {
      let content = await this.readFileContent(file);
      if (excludedSections.length > 0) {
        content = excludeSections(content);
      }
      concatenatedContent += `--- ${file.name} ---
${content}

`;
    }
    sortedNotes.forEach((file, index) => {
      const x = index % columns * (nodeWidth + spacingX);
      const y = Math.floor(index / columns) * (nodeHeight + spacingY);
      const color = getColorForNote(file);
      nodes.push(`
        {
            "id": "node-${index}",
            "x": ${x},
            "y": ${y},
            "width": ${nodeWidth},
            "height": ${nodeHeight},
            "type": "file",
            "file": "${file.path}",
            "color": "${color}"
        }`);
    });
    const concatenatedNodeX = (columns + 1) * (nodeWidth + spacingX);
    const concatenatedNodeY = 0;
    const concatenatedNodeWidth = nodeWidth * 2 + spacingX;
    const concatenatedNodeHeight = nodeHeight * 2 + spacingY;
    nodes.push(`
      {
        "id": "node-concatenated",
        "x": ${concatenatedNodeX},
        "y": ${concatenatedNodeY},
        "width": ${concatenatedNodeWidth},
        "height": ${concatenatedNodeHeight},
        "type": "text",
        "text": ${JSON.stringify(concatenatedContent)},
        "color": "#00FF00"
      }`);
    return `{
    "nodes":[${nodes.join(",")}],
    "edges":[${edges.join(",")}]
}`;
  }
  /**
   * Get the creation date of a file from its frontmatter.
   * @param {TFile} file - The file to get the creation date from.
   * @return {Date} The creation date of the file.
   */
  getCreationDate(file) {
    var _a;
    const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    const createdAt = frontmatter == null ? void 0 : frontmatter.created_at;
    return createdAt ? new Date(createdAt) : new Date(0);
  }
  /**
   * Get the value of a specified property from a file's frontmatter or its creation date.
   * @param {TFile} file - The file to get the property from.
   * @param {string} property - The name of the property to retrieve.
   * @return {any} The value of the property, or the file's creation date if not found.
   */
  getPropertyValue(file, property) {
    var _a, _b;
    const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    return (_b = frontmatter == null ? void 0 : frontmatter[property]) != null ? _b : file.stat.ctime;
  }
  resetPlugin() {
    this.stack = [];
    this.preservedNotes = [];
  }
};
var FileNameModal = class extends import_obsidian.Modal {
  constructor(app, resolve) {
    super(app);
    this.resolve = resolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Enter the file name" });
    this.input = new import_obsidian.TextComponent(contentEl);
    this.input.inputEl.style.width = "100%";
    this.input.inputEl.focus();
    this.input.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        event.stopPropagation();
        this.submitFileName();
      }
    });
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "10px";
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
      this.resolve(null);
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Submit").setCta().onClick(() => {
      this.submitFileName();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  submitFileName() {
    const fileName = this.input.getValue();
    if (fileName) {
      this.close();
      this.resolve(fileName);
    } else {
      new import_obsidian.Notice("Please enter a file name");
    }
  }
};


/* nosourcemap */